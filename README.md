# 网盘文件
这里是自写网盘的客户端  

![image-20240803105733799](mdimg\image-20240803105733799.png)

******
## 开发笔记
*2024/7/28*  
头文件**不能互相包含**  
对于客户端来说，kernel只是个中间值，因此不许要单例模式，
而客户端那边，kernel既要处理网络模块，又要处理数据库模块，
因此需要主动保证只有一份将其设为单例模式。  
在客户端这边主要是靠ui界面客户的操作，来处理数据。  
``dealdata``中来区分传来的包是什么包，目前有两种方案  

1. 通过switch判断
2. 通过协议映射表  

但是``switch``有一个弊端，就是我每增加包的一个种类就需要增加一个分支。  
所以我选择了协议映射表，通过协议映射表，``dealdata``内的代码就不需要在进行变动，
我只需要在表中增加数据就可以了。  
>所谓协议映射表，就是类似一个静态结构体（包）数组，通过遍历包的标识符（开头的第一个字节），来判断包是什么类型。  
>并在该数据结尾添加{0,0}来终止循环

``#include<XX.h>``回导入头文件的全部内容，并不会导入子下cpp文件，因此可以用此方法避免循环导入  
*2024/7/29*  
数据处理模块需要保证和网络模块为同一个kernel，因此可以把他设置为单例模式，或者传参传过去。  
kernel只在ui下new一份。其他地方不会再new。如果kernel不一致，qt信号和槽将会不一样。极度容易把发送信号的对象
弄错  
![我累个惊天大错误](./mdimg/71af0f6f17eb83386950cb9a23a4f69a.png "我累个惊天大错误")  
因为采用了网络模块采用了多线程线程，所以qt的第五个参数要更改为阻塞连接  
![8e3f3cc387589868f554f4f0a8dacf34](mdimg\8e3f3cc387589868f554f4f0a8dacf34.png)



*2024/8.1   文件上传*  
文件上传到服务器写完了，但是qt不支持中文路径，所以传输不可以中文路径传输。



*2024/8.2   文件分享功能完成*		

生成分享链接

分享码为a~z的四位随机数。

写入数据库，并记录时间，一定时间后清除不可访问。

通过分享链接来货的确文件地址，然后操作就是下载文件操作



*2024/8.3  文件下载功能完成*

通过``getExitingDirectory()``来选择一个目录打开并返回完整目录，如果是空，则提醒，并阻止下载。

![image-20240803105559695](mdimg\image-20240803105559695.png)

如果非空，则与文件名组成	``filePath``为下载做准备。通过一个映射表，``f_id->fileinfo``，来校验偏移量以及下载块的大小，如果块大小总和等于文件大小，则停止接收。

同时还区分传输类型（通过判断文件目录下是否有当前文件来判断是否为重传）

1. 断点重传：获取文件size来得到当前偏移量。然后移动read指针到pos处。然后进行传输。
2. 正常传

因为传输是单开的一个线程，所以可以传多个文件，所以会发生乱序，通过映射表，就可以避免这个问题。

对于下载文件，客户端先发送下文件的请求，其中包括要下载的文件名，以及用户id。

然后服务器通过文件名和用户id匹配文件id，成功后，返回回应包。

之后客户端判断文件传输类型，并传递给服务器

最后服务器根据客户端提供的传输类型，开始传输文件包

客户端接收并写入本地。

![具体流程](mdimg\d8680048c400d930277df184c6da1c6.jpg "具体流程")

